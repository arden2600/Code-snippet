## Linux Process<br>
这部分想用来记录自己对linux进程学习的相关知识内容。可以是学习笔记，总结记录，也可以是相关代码块的保存。<br>

### Linux进程基本概念总结<br>
在linux系统中，进程用于表示多用户，多任务的操作系统下，应用程序在内存环境中基本的执行单元的概念，是系统进行资源分配的最小单位。进程代表的是操作系统分配的内存，CPU时间片等资源的基本单位，是为正在运行的程序提供的运行环境。进程有进程控制表PCB,系统通过PCB对进程进行调度。<br>

在linux系统中，所有进程都是有父子或者堂兄关系的，除了初始进程init,没有那个进程与其他进程完全独立，**系统中每个进程都有一个父进程，当创建新的进程时候，通常不是被全新的创建，通常是从一个原有的进程进行复制或者克隆的**。

在Linux环境的操作系统中，来总结下进程如何产生，如何终止，进程之间如何通讯，进程之间如何进行共享资源同步等等方面的内容。<br>
**1. 进程的产生过程**<br>
进程的产生有多种方式，但是基本过程是一致的。<br>
(1)首先复制其父进程的环境配置(父进程在系统中的资源和相关记录)。<br>
(2)在内核中建立进程结构。(创建一个进程容器框架)<br>
(3)将结构插入到进程列表，便于维护。(相当于在系统进程中进行注册，通过操作系统可以管理该进程)<br>
(4)分配资源给此新建的进程。<br>
(5)复制父进程的内存映射信息。(?) <br>
(6)管理文件描述符(fd)和链接点。(linux所有进程都是文件，用文件描述符来表示文件)<br>
(7)通知父进程。(让父进程知道自己有个子进程，且子进程创建完毕，也分配得到了系统资源)<br>

**2. 进程的终止方式**<br>
在linux系统中，一个进行的终止方式大致有以下几种:<br>
A.进程运行正常，直接从main方法返回。<br>
B.程序显示调用exit命令，将该进行终止。<br>
C.调用_exit。同样将调用进程进行终止。<br>
D.调用abort命令，直接强制中断进行操作。<br>
E.由一个信号终止。进程之间的通信可以通过信号。<br>

进程无论是在主动终止，或者被动终止的时候，系统会释放进程所拥有的资源。例如内存，文件符和内核结构等。<br>


**3. 进程之间的通讯:IPC**<br>
因为在多进程，多任务的操作系统中，应用程序在执行任务的时候，通常都不可能是单一进程来完成。多数情况下，都是多个进行进行协同并发合作完成，那么，这些需要协同完成任务的进程又是如何进行信息交互，通信的呢？常见的方式有以下几种:<br>
1. 管道通信： 管道是UNIX家族中进行通信最古老的方式，即UNIX族操作系统创建出来开始就是用这种方式进行通信的。管道利用内核在两个进程之间建立通道，仅仅在管道的一端只读，另一端只写。也就是利用**读写方式**在进程中传递数据。<br>
2. 内存共享： 顾名思义，就是将操作系统中某一块内存地址，在多个进程之间共享，多个进程利用获得的内存地址来直接对共享内存进行操作。当然了，共享资源要进行资源互斥的一些管理。<br>
3. 消息队列： 消息队列则是在内核中建立一个链表，发送方按照一定的标识将数据发送到内核中，内核将其放入量表后，等待接收方的请求。接收方发送请求后，内核按照消息的标识，从内核中将消息从链表中取下，传递给接收方，消息队列是一种完全的异步操作方式。<br>

**4. 进程之间的同步**<br>
多个进程进行协同操作完成任务时候，经常发生任务之间的依赖现象，从而出现了进程的同步问题。linux下进程对资源的同步主要有消息队列，信号量等方式。<br>
信号量是一个共享的标识数量的值。用于多个进程之间操作或者共享资源的保护。它是进程之间同步的最主要方式。<br>

### Linux进程编程<br>

每个进程在初始化的时候，系统都分配了一个ID号，用于标识此进程。该进程号是唯一的，系统可以用这个值来标识一个进程，描述进程ID通常叫做PID。<br>
getpid()返回当前进程的ID号，getppid()返回当前进程的父进程ID号。<br>

* 使用fork()复制进程来创建新线程<br>
 fork()函数是以父进程为蓝本复制了一个进程，其ID号和父进程ID号不同，fork()在linux环境下是以**写复制**实现的。fork()特点是**执行一次，返回两次**。在父进程和子进程中返回的是不同的值，父进程中返回的是子进程的ID号，而在子进程则返回0，失败返回-1。<br>
 来个简单的示例:<br>
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>

int main(void){

	pid_t pid;
	/*分叉进程*/
	pid = fork();
	
	/*判断是否在内核中创建进程成功*/
	if(-1 == pid) {
		printf("创建进程失败！\n");
		return -1;
	} else if(pid == 0) {
		/*子进程中执行此代码段*/
		printf("子进程，fork返回值：%d, ID: %d,父进程ID: %d \n",pid,getpid(),getppid());
	} else {
		/*父进程中执行此代码段*/
		printf("父进程，fork返回值：%d, ID: %d,父进程ID: %d \n",pid,getpid(),getppid());
	}

	return 0;
}
```
